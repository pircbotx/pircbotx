<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>MultiBotManager.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pircbotx</a> &gt; <a href="index.source.html" class="el_package">org.pircbotx</a> &gt; <span class="el_source">MultiBotManager.java</span></div><h1>MultiBotManager.java</h1><pre class="source lang-java linenums">// Generated by delombok at Mon Apr 13 22:36:03 CEST 2020
/**
 * Copyright (C) 2010-2014 Leon Blakey &lt;lord.quackstar at gmail.com&gt;
 *
 * This file is part of PircBotX.
 *
 * PircBotX is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 *
 * PircBotX is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * PircBotX. If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package org.pircbotx;

import com.google.common.base.Joiner;
import com.google.common.collect.BiMap;
import com.google.common.collect.HashBiMap;
import com.google.common.util.concurrent.FutureCallback;
import com.google.common.util.concurrent.Futures;
import com.google.common.util.concurrent.ListenableFuture;
import com.google.common.util.concurrent.ListeningExecutorService;
import com.google.common.util.concurrent.MoreExecutors;
import static com.google.common.util.concurrent.Service.State;
import static com.google.common.base.Preconditions.*;
import com.google.common.collect.ImmutableSortedSet;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import lombok.NonNull;
import org.pircbotx.output.OutputIRC;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Manager that makes connecting and running multiple bots an easy, painless
 * process.
 * &lt;p&gt;
 * Lifecycle:
 * &lt;ol&gt;&lt;li&gt;When created, any added bots or configurations are queued&lt;/li&gt;
 * &lt;li&gt;When {@link #start()} is called, all queued bots are connected. Any bots
 * added after this point are automatically connected&lt;/li&gt;
 * &lt;li&gt;When {@link #stop()} is called, {@link OutputIRC#quitServer()} is called
 * on all bots. No more bots can be added, the Manager is finished. Note that an
 * optional {@link #stopAndWait() } method is provided to block until all bots
 * shutdown
 * &lt;/ol&gt; {@link #executeBot(org.pircbotx.PircBotX)} is overridable if you wish
 * to do your own connecting
 *
 * @author Leon Blakey
 */
public class MultiBotManager {
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@javax.annotation.Generated(&quot;lombok&quot;)
<span class="nc" id="L67">	private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(MultiBotManager.class);</span>
<span class="nc" id="L68">	protected static final AtomicInteger MANAGER_COUNT = new AtomicInteger();</span>
	protected final int managerNumber;
<span class="nc" id="L70">	protected final LinkedHashMap&lt;PircBotX, ListenableFuture&lt;Void&gt;&gt; runningBots = Maps.newLinkedHashMap();</span>
<span class="nc" id="L71">	protected final BiMap&lt;PircBotX, Integer&gt; runningBotsNumbers = HashBiMap.create();</span>
<span class="nc" id="L72">	protected final Object runningBotsLock = new Object[0];</span>
	protected final ListeningExecutorService botPool;
	//Code for starting
<span class="nc" id="L75">	protected List&lt;PircBotX&gt; startQueue = Lists.newArrayList();</span>
<span class="nc" id="L76">	protected State state = State.NEW;</span>
<span class="nc" id="L77">	protected final Object stateLock = new Object[0];</span>
	
	/**
	 * Create MultiBotManager with a cached thread pool.
	 */
<span class="nc" id="L82">	public MultiBotManager() {</span>
<span class="nc" id="L83">		managerNumber = MANAGER_COUNT.getAndIncrement();</span>
<span class="nc" id="L84">		ThreadPoolExecutor defaultPool = (ThreadPoolExecutor)Executors.newCachedThreadPool();</span>
<span class="nc" id="L85">		defaultPool.allowCoreThreadTimeOut(true);</span>
<span class="nc" id="L86">		this.botPool = MoreExecutors.listeningDecorator(defaultPool);</span>
<span class="nc" id="L87">	}</span>
	
	/**
	 * Create MultiBotManager with the specified thread pool.
	 *
	 * @param botPool A provided thread pool.
	 */
<span class="nc" id="L94">	public MultiBotManager(ExecutorService botPool) {</span>
<span class="nc" id="L95">		checkNotNull(botPool, &quot;Bot pool cannot be null&quot;);</span>
<span class="nc" id="L96">		this.botPool = MoreExecutors.listeningDecorator(botPool);</span>
<span class="nc" id="L97">		this.managerNumber = MANAGER_COUNT.getAndIncrement();</span>
<span class="nc" id="L98">	}</span>
	
	/**
	 * Alias of {@link #addNetwork(org.pircbotx.Configuration) }
	 *
	 * @param config
	 * @see #addNetwork(org.pircbotx.Configuration)
	 */
	public void addBot(Configuration config) {
<span class="nc" id="L107">		addNetwork(config);</span>
<span class="nc" id="L108">	}</span>
	
	/**
	 * Adds a managed bot using the specified configuration.
	 *
	 * @param config A configuration to pass to the created bot
	 */
	public void addNetwork(Configuration config) {
<span class="nc" id="L116">		synchronized (this.stateLock) {</span>
<span class="nc" id="L117">			checkNotNull(config, &quot;Configuration cannot be null&quot;);</span>
			//Since creating a bot is expensive, verify the state first
<span class="nc bnc" id="L119" title="All 4 branches missed.">			if (state != State.NEW &amp;&amp; state != State.RUNNING) throw new RuntimeException(&quot;MultiBotManager is not running. State: &quot; + state);</span>
<span class="nc" id="L120">			addNetwork(new PircBotX(config));</span>
<span class="nc" id="L121">		}</span>
<span class="nc" id="L122">	}</span>
	
	/**
	 * Alias of {@link #addNetwork(org.pircbotx.PircBotX) }
	 *
	 * @param bot
	 * @see #addNetwork(org.pircbotx.PircBotX)
	 */
	public void addBot(PircBotX bot) {
<span class="nc" id="L131">		addNetwork(bot);</span>
<span class="nc" id="L132">	}</span>
	
	/**
	 * Adds a bot to be managed.
	 *
	 * @param bot An existing &lt;b&gt;unconnected&lt;/b&gt; bot
	 */
	public void addNetwork(PircBotX bot) {
<span class="nc" id="L140">		synchronized (this.stateLock) {</span>
<span class="nc" id="L141">			checkNotNull(bot, &quot;Bot cannot be null&quot;);</span>
<span class="nc bnc" id="L142" title="All 2 branches missed.">			checkArgument(!bot.isConnected(), &quot;Bot must not already be connected&quot;);</span>
<span class="nc bnc" id="L143" title="All 2 branches missed.">			if (state == State.NEW) {</span>
<span class="nc" id="L144">				log.debug(&quot;Not started yet, add to queue&quot;);</span>
<span class="nc" id="L145">				startQueue.add(bot);</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">			} else if (state == State.RUNNING) {</span>
<span class="nc" id="L147">				log.debug(&quot;Already running, start bot immediately&quot;);</span>
<span class="nc" id="L148">				startBot(bot);</span>
<span class="nc" id="L149">			} else throw new RuntimeException(&quot;MultiBotManager is not running. State: &quot; + state);</span>
<span class="nc" id="L150">		}</span>
<span class="nc" id="L151">	}</span>
	
	/**
	 * Start the manager, connecting all queued bots.
	 */
	public void start() {
<span class="nc" id="L157">		synchronized (stateLock) {</span>
<span class="nc bnc" id="L158" title="All 2 branches missed.">			if (state != State.NEW) throw new RuntimeException(&quot;MultiBotManager has already been started. State: &quot; + state);</span>
<span class="nc" id="L159">			state = State.STARTING;</span>
<span class="nc" id="L160">		}</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">		for (PircBotX bot : startQueue) startBot(bot);</span>
<span class="nc" id="L162">		startQueue.clear();</span>
<span class="nc" id="L163">		synchronized (stateLock) {</span>
<span class="nc" id="L164">			state = State.RUNNING;</span>
<span class="nc" id="L165">		}</span>
<span class="nc" id="L166">	}</span>
	
	protected ListenableFuture&lt;Void&gt; startBot(final PircBotX bot) {
<span class="nc" id="L169">		checkNotNull(bot, &quot;Bot cannot be null&quot;);</span>
<span class="nc" id="L170">		ListenableFuture&lt;Void&gt; future = botPool.submit(new BotRunner(bot));</span>
<span class="nc" id="L171">		synchronized (runningBotsLock) {</span>
<span class="nc" id="L172">			runningBots.put(bot, future);</span>
<span class="nc" id="L173">			runningBotsNumbers.put(bot, bot.getBotId());</span>
<span class="nc" id="L174">		}</span>
<span class="nc" id="L175">		Futures.addCallback(future, new BotFutureCallback(bot));</span>
<span class="nc" id="L176">		return future;</span>
	}
	
	/**
	 * Stop with no quit message
	 * @see #stop(java.lang.String)
	 */
	public void stop() {
<span class="nc" id="L184">		stop(&quot;&quot;);</span>
<span class="nc" id="L185">	}</span>
	
	/**
	 * Disconnect all bots from their respective severs cleanly.
	 */
	public void stop(String quitMessage) {
<span class="nc" id="L191">		synchronized (stateLock) {</span>
<span class="nc bnc" id="L192" title="All 2 branches missed.">			if (state != State.RUNNING) throw new RuntimeException(&quot;MultiBotManager cannot be stopped again or before starting. State: &quot; + state);</span>
<span class="nc" id="L193">			state = State.STOPPING;</span>
<span class="nc" id="L194">		}</span>
<span class="nc bnc" id="L195" title="All 4 branches missed.">		for (PircBotX bot : runningBots.keySet()) if (bot.isConnected()) bot.sendIRC().quitServer(quitMessage);</span>
<span class="nc" id="L196">		botPool.shutdown();</span>
<span class="nc" id="L197">	}</span>
	
	/**
	 * {@link #stop()} and wait for all bots to disconnect.
	 *
	 * @throws InterruptedException If this is interrupted while waiting
	 */
	public void stopAndWait() throws InterruptedException {
<span class="nc" id="L205">		stop();</span>
<span class="nc" id="L206">		Joiner commaJoiner = Joiner.on(&quot;, &quot;);</span>
<span class="nc" id="L207">		do synchronized (runningBotsLock) {</span>
<span class="nc" id="L208">			log.debug(&quot;Waiting 5 seconds for bot(s) [{}] to terminate &quot;, commaJoiner.join(runningBots.values()));</span>
<span class="nc bnc" id="L209" title="All 2 branches missed.">		}		 while (!botPool.awaitTermination(5, TimeUnit.SECONDS));</span>
<span class="nc" id="L210">	}</span>
	
	/**
	 * Get all the bots that this MultiBotManager is managing.
	 *
	 * @return An &lt;i&gt;immutable copy&lt;/i&gt; of bots that are being managed
	 */
	public ImmutableSortedSet&lt;PircBotX&gt; getBots() {
<span class="nc" id="L218">		synchronized (this.runningBotsLock) {</span>
<span class="nc" id="L219">			return ImmutableSortedSet.copyOf(runningBots.keySet());</span>
<span class="nc" id="L220">		}</span>
	}
	
	/**
	 * Lookup a managed bot by id.
	 *
	 * @param id The id of the bot
	 * @return A bot that has the specified id or null
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public &lt;B extends PircBotX&gt; B getBotById(int id) {
<span class="nc" id="L231">		synchronized (this.runningBotsLock) {</span>
<span class="nc" id="L232">			return (B)runningBotsNumbers.inverse().get(id);</span>
<span class="nc" id="L233">		}</span>
	}
	
	/**
	 * Called when
	 *
	 * @param bot
	 */
	protected void executeBot(PircBotX bot) throws Exception {
<span class="nc" id="L242">		bot.startBot();</span>
<span class="nc" id="L243">	}</span>
	
	protected class BotRunner implements Callable&lt;Void&gt; {
		@NonNull
		protected final PircBotX bot;
		
		public Void call() throws Exception {
<span class="nc" id="L250">			Thread.currentThread().setName(&quot;botPool&quot; + managerNumber + &quot;-bot&quot; + bot.getBotId());</span>
<span class="nc" id="L251">			Utils.addBotToMDC(bot);</span>
<span class="nc" id="L252">			executeBot(bot);</span>
<span class="nc" id="L253">			return null;</span>
		}
		
		@java.beans.ConstructorProperties({&quot;bot&quot;})
		@java.lang.SuppressWarnings(&quot;all&quot;)
		@javax.annotation.Generated(&quot;lombok&quot;)
<span class="nc" id="L259">		public BotRunner(@NonNull final PircBotX bot) {</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">			if (bot == null) {</span>
<span class="nc" id="L261">				throw new java.lang.NullPointerException(&quot;bot&quot;);</span>
			}
<span class="nc" id="L263">			this.bot = bot;</span>
<span class="nc" id="L264">		}</span>
	}
	
	protected class BotFutureCallback implements FutureCallback&lt;Void&gt; {
<span class="nc" id="L268">		protected final Logger log = LoggerFactory.getLogger(getClass());</span>
		@NonNull
		protected final PircBotX bot;
		
		public void onSuccess(Void result) {
<span class="nc" id="L273">			log.debug(&quot;Bot #&quot; + bot.getBotId() + &quot; finished&quot;);</span>
<span class="nc" id="L274">			remove();</span>
<span class="nc" id="L275">		}</span>
		
		public void onFailure(Throwable t) {
<span class="nc" id="L278">			log.error(&quot;Bot exited with Exception&quot;, t);</span>
<span class="nc" id="L279">			remove();</span>
<span class="nc" id="L280">		}</span>
		
		protected void remove() {
<span class="nc" id="L283">			synchronized (runningBotsLock) {</span>
<span class="nc" id="L284">				runningBots.remove(bot);</span>
<span class="nc" id="L285">				runningBotsNumbers.remove(bot);</span>
				//Change state to TERMINATED if this is the last but to be removed during shutdown
<span class="nc bnc" id="L287" title="All 4 branches missed.">				if (runningBots.isEmpty() &amp;&amp; state == State.STOPPING) synchronized (stateLock) {</span>
<span class="nc bnc" id="L288" title="All 2 branches missed.">					if (state == State.STOPPING) state = State.TERMINATED;</span>
<span class="nc" id="L289">				}</span>
<span class="nc" id="L290">			}</span>
<span class="nc" id="L291">		}</span>
		
		@java.beans.ConstructorProperties({&quot;bot&quot;})
		@java.lang.SuppressWarnings(&quot;all&quot;)
		@javax.annotation.Generated(&quot;lombok&quot;)
<span class="nc" id="L296">		public BotFutureCallback(@NonNull final PircBotX bot) {</span>
<span class="nc bnc" id="L297" title="All 2 branches missed.">			if (bot == null) {</span>
<span class="nc" id="L298">				throw new java.lang.NullPointerException(&quot;bot&quot;);</span>
			}
<span class="nc" id="L300">			this.bot = bot;</span>
<span class="nc" id="L301">		}</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>